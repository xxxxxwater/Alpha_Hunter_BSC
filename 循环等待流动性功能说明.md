# 循环等待流动性功能说明

## 功能概述

新增了**循环等待流动性**功能，专为新上线的代币设计。当检测不到流动性池时，程序可以持续循环检测，一旦发现流动性立即执行买入，无需手动重复操作。

## 适用场景

### ✅ 推荐使用
1. **新币开盘** - 代币即将添加流动性，等待开盘时机
2. **预售结束** - 预售结束后等待流动性添加
3. **手动狙击** - 确定代币即将上线，需要快速进场
4. **流动性迁移** - 流动性正在从一个DEX迁移到另一个

### ❌ 不推荐使用
1. **已有流动性的代币** - 直接买入即可
2. **代币地址错误** - 会一直等待无结果
3. **废弃项目** - 永远不会有流动性

## 使用方法

### 方式1: 通过菜单选择（推荐）

1. 运行程序后输入代币地址
2. 如果检测不到流动性，会显示选择菜单：

```
============================================================
[警告] 未检测到流动性池
============================================================

可能原因:
  1. 代币尚未添加流动性
  2. LI.FI暂时无法找到交易路径
  3. 代币地址错误

选项:
  1. 退出程序
  2. 循环等待流动性出现（推荐新币）
  3. 忽略并继续尝试买入

请选择 (1/2/3): 
```

3. 选择 `2` 启用循环等待模式
4. 设置检测间隔（默认30秒）
5. 程序开始循环检测，发现流动性立即买入

### 方式2: 命令行直接启动

```bash
python auto_trade_lifi.py
```

## 工作流程

```
开始
  ↓
输入代币地址
  ↓
尝试获取流动性 ──→ 成功 ──→ 显示价格 ──→ 确认买入
  ↓ 失败
显示选择菜单
  ↓
选择: 循环等待
  ↓
设置检测间隔
  ↓
┌─────────────────┐
│  循环检测流动性  │ ←──┐
│  (每30秒一次)    │    │
└─────────────────┘    │
  ↓                    │
检测到流动性? ──否────┘
  ↓ 是
立即执行买入
  ↓
买入成功
  ↓
启动自动监控止盈
```

## 配置选项

### 检测间隔

**默认**: 30秒  
**建议**: 
- 普通项目：30-60秒
- 热门项目：15-30秒  
- 低优先级：60-120秒

**注意**: 间隔太短可能触发API限流

### .env配置

可以在 `.env` 文件中预设默认值：

```bash
# 是否默认启用循环等待（true/false）
WAIT_FOR_LIQUIDITY=false

# 默认检测间隔（秒）
RETRY_INTERVAL=30

# API限流保护（每分钟最大请求数）
MAX_REQUESTS_PER_MINUTE=20
```

## 实时日志

### 正常检测流程

```
[->] 准备买入代币...
[TOKEN] 代币地址: 0xd4058218632112de109846a2952be102d0330ab3
[BNB] 投入: 0.025 BNB
[DATA] 滑点: 10.0%
[LIFI] 使用LI.FI聚合器
[MODE] 循环等待模式
[INTERVAL] 检测间隔: 30秒

[RETRY] 第 1 次尝试...
[QUOTE] 通过LI.FI获取最优报价...
[WAIT] 未检测到流动性池，等待 30秒后重试...
[TIP] 按 Ctrl+C 可随时停止等待

[RETRY] 第 2 次尝试...
[QUOTE] 通过LI.FI获取最优报价...
[WAIT] 未检测到流动性池，等待 30秒后重试...

[RETRY] 第 3 次尝试...
[QUOTE] 通过LI.FI获取最优报价...
[OK] 报价成功!
[RECEIVE] 预计获得: 1234567.890000 代币
[DEX] 通过: PancakeSwap V2
[SIGN] 签名交易...
[SEND] 发送交易...
```

### 检测到流动性

```
[RETRY] 第 15 次尝试...
[QUOTE] 通过LI.FI获取最优报价...
[OK] 报价成功!
[RECEIVE] 预计获得: 5000000.000000 代币
[DEX] 通过: PancakeSwap V2

[SIGN] 签名交易...
[SEND] 交易已发送: 0x1234...
[SCAN] https://bscscan.com/tx/0x1234...
[WAIT] 等待交易确认...
[OK] 买入成功! Gas: 250000
```

## 安全机制

### 1. API限流保护

程序内置限流保护，避免过度请求：
- 每次检测间隔至少30秒（可配置）
- 失败后自动延长等待时间
- 检测到429错误自动暂停

### 2. 余额检查

每次尝试买入前都会检查：
- BNB余额是否充足
- 是否有足够的Gas费预留

### 3. 手动中断

随时可以按 `Ctrl+C` 停止等待：
```
[WAIT] 未检测到流动性池，等待 30秒后重试...
[TIP] 按 Ctrl+C 可随时停止等待
^C
[CANCEL] 用户取消等待
```

### 4. 超时保护

虽然理论上可以无限等待，但建议：
- 设置合理的检测间隔
- 定期检查代币信息是否正确
- 避免长时间无人监管

## 实战示例

### 示例1: 新币开盘狙击

**场景**: 某新币将在14:00添加流动性

**操作**:
```bash
# 13:55 运行程序
python auto_trade_lifi.py

# 输入代币地址
代币合约地址: 0xNEWTOKEN...

# 检测不到流动性，选择循环等待
请选择 (1/2/3): 2

# 设置15秒检测间隔（快速响应）
检测间隔（秒，默认30）: 15

# 程序开始循环检测
[RETRY] 第 1 次尝试...
[WAIT] 未检测到流动性池，等待 15秒后重试...
...

# 14:00 流动性添加，程序自动检测到
[RETRY] 第 20 次尝试...
[OK] 报价成功!
[RECEIVE] 预计获得: 10000000 代币

# 自动执行买入
[SEND] 交易已发送...
[OK] 买入成功!
```

### 示例2: 预售后等待

**场景**: 代币预售结束，等待添加流动性

**操作**:
```bash
# 运行程序
python auto_trade_lifi.py

# 输入代币地址
代币合约地址: 0xPRESALE...

# 选择循环等待
请选择 (1/2/3): 2

# 使用默认30秒间隔
检测间隔（秒，默认30）: [直接回车]

# 可以去做其他事情，程序自动监控
# 发现流动性后自动买入并通知
```

### 示例3: 手动中断

**场景**: 等待中发现代币信息有误

**操作**:
```bash
[RETRY] 第 5 次尝试...
[WAIT] 未检测到流动性池，等待 30秒后重试...

# 按 Ctrl+C 中断
^C

[CANCEL] 用户取消等待
[FAILED] 买入失败

# 程序退出，可以重新检查代币信息
```

## 性能统计

### API调用频率

```
检测间隔: 30秒
每小时调用: 120次
每天调用: 2880次

检测间隔: 60秒  
每小时调用: 60次
每天调用: 1440次
```

### 建议配置

| 场景 | 检测间隔 | 每小时调用 | 说明 |
|------|---------|----------|------|
| 热门新币 | 15秒 | 240次 | 快速响应 |
| 普通新币 | 30秒 | 120次 | 平衡 ⭐推荐 |
| 低优先级 | 60秒 | 60次 | 节省资源 |
| 长期等待 | 120秒 | 30次 | 最低频率 |

## 常见问题

### Q1: 会一直等待吗？

A: 是的，除非你手动中断（Ctrl+C）。建议设置合理的检测间隔，定期检查程序状态。

### Q2: API限流怎么办？

A: 程序内置限流保护。如果检测到429错误，会自动增加等待时间。建议检测间隔不低于30秒。

### Q3: 如何知道检测了多少次？

A: 日志会显示尝试次数：
```
[RETRY] 第 10 次尝试...
[RETRY] 第 11 次尝试...
```

### Q4: 中途可以修改间隔吗？

A: 当前版本不支持。如需修改，需要中断程序重新启动。

### Q5: 会错过开盘时机吗？

A: 极小概率。检测间隔越短，响应越快。建议热门新币使用15-30秒间隔。

### Q6: 可以同时监控多个代币吗？

A: 当前版本一次只能监控一个代币。需要多个代币请启动多个程序实例。

### Q7: 如何提高成功率？

A: 
- 使用较短的检测间隔（15-30秒）
- 确保BNB余额充足（含Gas费）
- 设置合理的滑点（10-20%）
- 使用快速的RPC节点

## 技术细节

### 流动性检测原理

```python
# 1. 构建查询参数
params = {
    'fromToken': BNB,
    'toToken': target_token,
    'amount': investment_amount
}

# 2. 调用LI.FI API
response = lifi_api.get_quote(params)

# 3. 判断流动性
if response.status == 200:
    # 检测到流动性
    return True
else:
    # 未检测到流动性  
    return False
```

### 重试机制

```python
retry_count = 0
while True:
    retry_count += 1
    
    # 尝试获取报价
    quote = get_quote(token)
    
    if quote:
        # 成功，执行买入
        break
    
    # 失败，等待后重试
    logger.info(f"第 {retry_count} 次尝试")
    time.sleep(retry_interval)
```

### API限流保护

```python
# 全局限流器
rate_limiter = RateLimiter(
    max_requests_per_minute=20
)

# 每次请求前检查
rate_limiter.wait_if_needed()

# 发起API请求
response = api_call()
```

## 更新日志

### v1.1.0 (2025-10-27)
- ✅ 新增循环等待流动性功能
- ✅ 添加可配置的检测间隔
- ✅ 改进API限流保护
- ✅ 优化错误提示和日志
- ✅ 支持手动中断（Ctrl+C）

### v1.0.0 (2025-10-20)
- 初始版本
- 基础LI.FI交易功能

## 相关文档

- [问题排查指南.md](问题排查指南.md)
- [双聚合器版本说明.md](双聚合器版本说明.md)
- [README.md](README.md)

## 反馈与建议

如有问题或建议，请通过以下方式反馈：
- GitHub Issues
- 社区论坛
- 技术支持邮箱

---

**最后更新**: 2025-10-27  
**功能状态**: ✅ 稳定可用

